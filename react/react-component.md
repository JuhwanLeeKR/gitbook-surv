# react component

<!-- TODO: thinking react 문서 읽기 -->

<!-- - REST API 와 GraphQL
  - REST API 란 무엇인가
  - GraphQL은 왜 등장했는가?
  - REST API vs GraphQL
- JSON
- DSL(Domain-Specific Language)
- 선언형 프로그래밍
- 명령형 프로그래밍
- SRP(단일 책임 원칙)
- Atomic Design
- React component 와 props -->

## REST API 와 GraphQL

### REST API

**REST API**는 Representational State Transfer의 약자로, 웹 표준에 따른 아키텍처 스타일 중 하나다.
자원(Resource)의 표현(Representation)에 의한 상태 전달을 의미한다.
자원은 URI로 식별되며, 해당 자원의 상태(데이터)는 HTML, XML, JSON 등의 형식으로 전달된다.
REST는 자원 기반의 구조 설계에 있어 HTTP 메소드를 통해 자원을 처리하는 방식을 사용하며, 주로 GET, POST, PUT, DELETE와 같은 메소드를 사용한다.

### GraphQL

**GraphQL**은 2015년 Facebook에 의해 공개된 데이터 쿼리 언어다. REST API의 한계를 극복하기 위해 등장했다.
클라이언트가 서버로부터 필요한 정보만을 정확히 요청하여 받아올 수 있게 해줌으로써, 오버페칭(필요 이상의 데이터를 받는 것)과 언더페칭(필요한 데이터를 충분히 받지 못하는 것)을 방지할 수 있다. 또한, 여러 자원을 하나의 요청으로 가져올 수 있어 데이터 로딩을 효율적으로 할 수 있다.

>❓ **REST API의 한계는 무엇일까?**
>
>1. 오버페칭(Over-fetching): 클라이언트가 필요한 데이터보다 더 많은 정보를 받아야 하는 경우가 있다. 특정 기능에 필요한 데이터만 요청하고 싶어도, 서버에서 제공하는 표준 응답에는 필요하지 않은 추가 데이터가 포함될 수 있다.
>2. 언더페칭(Under-fetching)과 N+1 문제: 언더페칭은 필요한 모든 데이터를 한 번의 요청으로 받지 못하여 여러 번의 추가 요청을 해야 하는 상황을 의미한다. 예를 들어, 웹 페이지에서 사용자 정보와 해당 사용자의 게시글 목록을 표시해야 할 때, 사용자 정보를 가져오는 요청과 게시글 목록을 가져오는 별도의 요청을 해야 하는 경우가 이에 해당한다. 이러한 문제는 N+1 문제로 이어질 수 있으며, 애플리케이션의 성능 저하를 초래할 수 있다.
>3. 버전 관리: API를 업데이트하거나 기능을 추가할 때, 기존 클라이언트와의 호환성을 유지하기 위해 버전 관리가 필요하다. REST API에서는 새로운 버전의 API를 배포하고 관리하는 것이 복잡할 수 있으며, 때로는 이전 버전과 새 버전을 동시에 운영해야 할 수도 있다.
>4. 상태 관리: REST는 상태를 유지하지 않는(stateless) 통신을 원칙으로 한다. 이는 각 요청이 독립적이라는 장점을 가지지만, 복잡한 트랜잭션이나 사용자 세션 관리에서 추가적인 로직을 서버 측에 구현해야 하는 단점도 있다.
>5. 효율적인 캐싱의 어려움: REST API를 사용할 때, HTTP 헤더를 통한 캐싱 전략을 구현할 수 있으나, 복잡한 동적 콘텐츠의 경우 효율적인 캐싱이 어려울 수 있다. 이는 네트워크 요청의 수를 줄이고 성능을 향상시키는 데 제한적일 수 있다.

>❓ **N+1 문제란 무엇일까?**
>
>N+1 문제는 데이터베이스 쿼리의 비효율적인 패턴을 가리키는 용어로, 주로 ORM(Object-Relational Mapping)을 사용할 때 발생한다. 이 문제는 하나의 데이터를 가져온 후, 연관된 데이터를 가져오기 위해 추가적인 쿼리가 N번 실행되어야 하는 상황을 말한다. 여기서 "N"은 처음에 가져온 데이터의 수를 의미한다.
>
>예를 들어, 블로그 포스트 목록을 데이터베이스에서 가져온 후, 각 포스트의 댓글을 가져오기 위해 각 포스트마다 별도의 쿼리를 실행한다면, 이는 N+1 쿼리 문제의 전형적인 사례이다. 처음의 1번 쿼리는 포스트 목록을 가져오는 것이고, 추가적인 N번의 쿼리는 각 포스트의 댓글을 가져오기 위해 실행된다.
>
> **N+1 문제의 문제점**
>
>- 성능 저하: 데이터베이스에 대한 과도한 수의 쿼리가 실행되어, 애플리케이션의 성능이 저하될 수 있다.
>- 리소스 낭비: 네트워크 트래픽 증가와 데이터베이스 서버의 부하가 증가하여 시스템 리소스가 낭비될 수 있다.
>- 응답 시간 증가: 사용자에게 데이터를 보여주기까지의 시간이 길어져, 사용자 경험이 저하될 수 있다.
>
>**N+1 문제 해결 방법**
>
>- 조인(Joins) 사용: 가능한 경우, 조인을 사용하여 필요한 모든 데이터를 하나의 쿼리로 가져올 수 있다.
>- 배치(Batch) 쿼리: 연관된 데이터를 한 번에 가져올 수 있는 배치 쿼리 기법을 사용한다.
>- Eager Loading: ORM 기능을 활용하여 처음 쿼리 실행 시, 연관된 데이터도 함께 로드하는 전략을 사용한다.
>- Caching: 자주 요청되는 데이터에 대해 캐싱을 적용하여 데이터베이스 쿼리 수를 줄일 수 있다.
>- N+1 문제를 인식하고 적절한 해결 방법을 적용하는 것은 데이터베이스 기반 애플리케이션의 성능을 최적화하는 데 중요한 부분이다.

### REST API vs GraphQL

- **데이터 요청 및 응답**: REST API는 자원을 URI로 식별하고 HTTP 메소드를 통해 CRUD 작업을 수행한다. GraphQL은 단일 엔드포인트를 통해 필요한 데이터만 정확히 요청할 수 있다.
- **성능 및 효율성**: GraphQL은 오버페칭과 언더페칭을 방지하며, 네트워크 요청의 횟수를 줄여 효율적이다.
- **유연성**: GraphQL은 타입 시스템을 기반으로 하여 쿼리의 정확성을 보장하며, 클라이언트에서 요청하는 데이터 구조를 결정할 수 있다.

## JSON

**JSON**(JavaScript Object Notation)은 경량의 데이터 교환 포맷이다. 인간이 읽을 수 있는 텍스트로, 서버와 클라이언트 사이에서 데이터를 교환하기 위해 사용된다. 언어 독립적이다.

## DSL (Domain-Specific Language)

**DSL**은 특정 영역에 특화된 프로그래밍 언어다. 특정 분야의 문제를 해결하기 위해 만들어지며, SQL이나 HTML과 같은 언어가 이에 해당한다.

## 선언형 프로그래밍

**선언형 프로그래밍**은 '무엇을 할 것인가'에 초점을 맞춘 프로그래밍 패러다임이다. 결과를 얻기 위해 원하는 바를 선언하는 방식이며, SQL이 대표적인 예이다.

## 명령형 프로그래밍

**명령형 프로그래밍**은 '어떻게 할 것인가'에 초점을 맞춘 프로그래밍 패러다임이다. 알고리즘을 명시하고 명령어를 통해 컴퓨터에게 작업을 수행하게 한다.

## SRP (Single Responsibility Principle)

**SRP**(단일 책임 원칙)은 클래스가 단 하나의 책임만을 가져야 한다는 원칙이다. 소프트웨어의 유지보수성과 재사용성을 높이는 데 도움을 준다.

## Atomic Design

**Atomic Design**은 웹 페이지를 구성하는 요소를 원자, 분자, 유기체, 템플릿, 페이지로 나누어 생각하는 디자인 시스템이다. 디자인의 일관성을 유지하고 효율적으로 구축할 수 있다.

## React component와 props

**React component**는 React 앱을 구성하는 재사용 가능한 코드 조각이다. UI의 독립적인 부분을 나타낸다.

**Props**는 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달할 때 사용되는 방법이다. 컴포넌트의 초기 구성요소 또는 동적 UI 업데이트에 사용된다.

>**참고 링크**
>
>- [REST API](https://restfulapi.net/)
>- [GraphQL](https://graphql.org/)
>- [JSON](https://www.json.org/json-en.html)
>- [선언형 vs 명령형 프로그래밍](https://tylermcginnis.com/imperative-vs-declarative-programming/)
>- [단일 책임 원칙](https://en.wikipedia.org/wiki/Single-responsibility_principle)
>- [Atomic Design](https://atomicdesign.bradfrost.com/)
>- [React 공식 문서](https://reactjs.org/docs/components-and-props.html)
